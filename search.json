[{"title":"2.队列操作","url":"/2025/05/20/1%E3%80%81freertos/2%E3%80%81%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C2/","content":"esp32里面跑的是freertos,如果需要传递数据需要使用内部的缓存管理.\n任务间同步RTOS中的同步，是指不同任务之间或者任务与外部事件之间的协同工作方式，确保多个并发执行的任务按照预期的顺序或时机执行。它设计到线程或任务间的通信和协调机制，目的是为了避免数据竞争、解决竞态条件，并确保系统的正确行为。\n互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。\n![[Pasted image 20250518093926.png]]\nQueueHandle_t xQueueCreate(//创建一个队列，成功返回队列句柄\tUBaseType_t uxQueueLength,//队列容量\tUBaseType_t uxltemSize    //每个队列项所占内存的大小（单位是字节）);BaseType_t xQueueSend(//向队列头部发送一个消息\tQueueHandle_t xQueue,//队列句柄\tconst void * pvItemToQueue,//要发送的消息指针\tTickType_t xTicksToWait//等待时间);BaseType_t xQueueSendToBack(//向队列尾部发送一个消息\tQueueHandle_t xQueue,//队列句柄\tconst void * pvItemToQueue,//要发送的消息指针\tTickType_t xTicksToWait//等待时间);BaseType_t xQueueReceive(//从队列接收一条信息\tQueueHandle_t xQueue,//队列句柄\tvoid * const pvBuffer,//指向接收消息缓冲区的指针\tTickType_t xTicksToWait//等待时间);BaseType_t xQueueSendFromISR(//xQueueSend的中断版本\tQueueHandle_t xQueue,//队列句柄\tconst void * pvItemToQueue,//要发送的消息指针\tBaseType_t *pxHigherPriorityTaskWoken//如果发送到队列导致任务解除阻塞，且解除阻塞的任务的优先级高于当前运行的任务，则xQueueSendFromISR会将 *pxHigherPriorityTaskWoken设置为pdTRUE，如果xQueueSendFromISR()将此值设置为pdTRUE，则应在中断退出前要执行请求上下文切换函数);\n\n\n\n实例代码#include &lt;stdio.h&gt;#include &quot;esp_log.h&quot;                 // ESP-IDF 日志模块#include &quot;freertos/FreeRTOS.h&quot;      // FreeRTOS 主头文件#include &quot;freertos/task.h&quot;          // 任务管理相关#include &quot;freertos/queue.h&quot;         // 队列管理相关#include &quot;string.h&quot;                 // 字符串和内存操作// 创建一个队列句柄，用于任务之间的通信QueueHandle_t queue_handle = NULL;// 定义一个结构体，用于传输的数据类型typedef struct&#123;    int value; // 整型数据字段&#125; queue_data_t;// 任务A：从队列中接收数据并打印出来void TaskA(void * param)&#123;    queue_data_t data;    while (1)    &#123;        // 尝试接收队列中的数据，超时时间为100个Tick        if(pdTRUE == xQueueReceive(queue_handle, &amp;data, 100))        &#123;            ESP_LOGI(&quot;queue&quot;, &quot;receive queue value: %d&quot;, data.value);        &#125;        // 若没有数据可读，则会超时后继续下一轮循环    &#125;&#125;// 任务B：每隔1秒向队列中发送数据void TaskB(void * param)&#123;    queue_data_t data;    memset(&amp;data, 0, sizeof(queue_data_t));  // 将结构体初始化为0    while (1)    &#123;        // 向队列中发送数据，超时时间为100个Tick        xQueueSend(queue_handle, &amp;data, 100);        // 任务延时1秒（1000ms）        vTaskDelay(pdMS_TO_TICKS(1000));        // 每次发送后将value加1        data.value++;    &#125;&#125;// 主函数：系统入口点void app_main(void)&#123;    // 创建一个长度为10的队列，每个元素大小为queue_data_t结构体的大小    queue_handle = xQueueCreate(10, sizeof(queue_data_t));    // 创建任务A，运行在核心1上，优先级为3，栈大小2048字节    xTaskCreatePinnedToCore(TaskA, &quot;taskA&quot;, 2048, NULL, 3, NULL, 1);    // 创建任务B，同样运行在核心1上    xTaskCreatePinnedToCore(TaskB, &quot;taskB&quot;, 2048, NULL, 3, NULL, 1);&#125;\n\n\n![[Pasted image 20250518104230.png]]\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","FreeRTOS"]},{"title":"1.创建任务","url":"/2025/05/20/1%E3%80%81freertos/1.%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A11/","content":"任务可以存在于以下状态：运行：当任务实际执行时，它被称为处于运行状态。任务当前正在使用处理机。如果运行RTOS的处理器只有一个内核，那么在任何给定时间内都只能有一个任务处于运行状态。\n准备就绪：准备就绪任务指那些能够执行（它们不处于阻塞或挂起状态），但目前没有执行的任务，因为同等或更高优先级的不同任务已经处于运行状态。\n阻塞：如果任务当前正在等待时间或外部时间，则该任务被认为处于阻塞状态。例如，如果一个任务调用vTaskDelay()，它将被阻塞（被置于阻塞状态），直到延迟结束一个时间事件。任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量事件。处于阻塞状态的任务通常有一个“超时”期，超时后任务被超时，并被解除阻塞，即使该任务所等待的事件没有发生。\n“阻塞”状态下的任务不使用任何处理时间，不能 被选择进入运行状态。\n挂起：与“阻塞”状态下的任务一样，“挂起”状态下的任务不能 被选择进入运行状态，但处于挂起状态的任务 没有超时。相反，任务只有在分别通过vTaskSuspend() 和 xTaskResume() API调用明确命令时才会进入或退出挂起状态。\n任务创建![[Pasted image 20250515092426.png]]\nBase Type_t xTaskCreatePinnedToCore(\tTaskFunction pvTaskCode,//任务函数指针，原型是void fun(void *param)\tconst char * constpcName,//任务的名称，打印调试可能会有用\tconst uint32_t usStackDepth,//指定的任务堆栈空间大小（字节）\tvoid * constpvParameters,//任务参数\tUBaseType_t uxPriority,//优先级，数字越大，优先级越大，0到（configMAX_PRIORITIES-1）\tTaskHandle_t * constpvCreatedTask,//传回来的任务句柄\tconst BaseType_t xCoreID//分配在哪个内核运行)\n关于栈区大小任务在运行的时候,每个任务是来回切换运行的,操作系统在切换别的任务运行的时候,会把当前任务运行的寄存器,变量的值存储到内存(ram)里面.\n 当再次回到这个任务运行的时候,从内存把寄存器,变量的值读取出来,这样子的话就可以接着上次运行了.\n阻塞![[Pasted image 20250515094654.png]]\n//延时xTicksToDelay个周期void vTaskDelay(const TickType_t xTicksToDelay)//用于表示精确的解除阻塞时间void vTaskDelayUntil(TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement);//参数1：保存了上一次任务解除阻塞的时间，//参数2:1+2后结束阻塞cnt = xTaskGetTickCount();//获取当前系统节拍数while(1)&#123;\tvTaskDelayUntil(&amp;cnt, 100);\t···&#125;\n\n\n\n实例代码#include &lt;stdio.h&gt;#include &quot;esp_log.h&quot;#include &quot;freertos\\FreeRTOS.h&quot;#include &quot;freertos\\task.h&quot;QueueHandle_t queue_handle = NULL;typedef struct&#123;    int value;&#125;queue_data_t;void taskA(void * param)&#123;    while (1)    &#123;        ESP_LOGI(&quot;main&quot;,&quot;Hello world!&quot;);        vTaskDelay(pdMS_TO_TICKS(500));        //vTaskDelay(500/portTICK_PERIOD_MS);    &#125;&#125;void app_main(void)&#123;    xTaskCreatePinnedToCore(taskA, &quot;helloworld&quot;, 2048, NULL, 3, NULL, 1);&#125;\n\n\n难道使用了 2048-568 &#x3D; 1480 ????\n 一个啥也没有的任务不可能使用这么多的,其实返回的是这个任务运行的时候使用的最大空间.\n 但是网络是都是说这个函数是剩下的栈空间呢? 如何解释?\n其实是栈的生长方向的问题!\n首先呢保存数据就是使用的数组保存的,数组有首地址和尾地址.\n假设存储数据的时候是从首地址开始存储的,假设存储了568个数据,那么数据最大存储在568这个地址\n那么就剩余1480个空间没有使用.那么返回的时候返回剩下的就是1480;\n如果存储数据的时候是从数组的尾地址开始存储的,假设存储568个数据,其实数据是存储到 2047,2046,…,1479,1480 这些地址上\n最终存储的地址是1480,但是呢从数组的首地址开始计算的话就会认为存储了1480个数据\n那么便会计算出剩余568,正好和上面的相反.所以才返回568.\n一般呢把空间设置为实际使用空间的1.5倍或者2倍就可以 568****2&#x3D;1136\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","FreeRTOS"]},{"title":"5.对比","url":"/2025/05/21/1%E3%80%81freertos/5%E3%80%81%E5%AF%B9%E6%AF%945/","content":"\n\n\n机制\n用途\n特点\n适用场景\n\n\n\n队列（Queue）\n传递数据\n支持多个数据项排队\n任务间传递结构体&#x2F;数值等数据\n\n\n信号量（Semaphore）\n同步 &#x2F; 互斥\n不传递数据，只传“信号”\n同步事件、任务间或中断间的配合\n\n\n互斥锁（Mutex）\n资源互斥保护\n特殊的二值信号量 + 优先级继承\n多任务访问共享资源（如 I²C、串口）\n\n\n事件组（Event Group）\n多位同步控制\n可同时表示多个状态位\n控制多个条件满足才执行，如联网、就绪等\n\n\n任务通知（Task Notification）\n点对点通知 + 可传值\n轻量，效率高，限单任务\n一对一传递信号或数据\n\n\n🧩 各模块详细对比1. ✅ 队列（Queue）\n可以传递数据（整数、结构体等）\n\n先进先出（FIFO）机制\n\n可以阻塞等待队列满或空\n\n支持任务与任务 &#x2F; 中断与任务之间通信\n\n\n🔧 示例用途：\nxQueueSend(queue, &amp;data, portMAX_DELAY);     // 发送数据 xQueueReceive(queue, &amp;data, portMAX_DELAY);  // 接收数据\n\n2. ✅ 信号量（Semaphore）2.1 二值信号量（Binary Semaphore）\n只表示 “有&#x2F;无” 两种状态，不传值\n\n用于同步（如：等待中断、事件触发）\n\n\n2.2 计数信号量（Counting Semaphore）\n可以累加的“计数器”\n\n适用于某种资源有多个实例\n\n\n🔧 示例用途：\nxSemaphoreGive(binary_sema);         // 发送信号（如 ISR 中） xSemaphoreTake(binary_sema, portMAX_DELAY);  // 等待信号\n\n3. ✅ 互斥锁（Mutex）\n本质是 带优先级继承的二值信号量\n\n专门用于多个任务之间 保护共享资源\n\n只允许一个任务持有，其他任务会阻塞等待\n\n任务释放后会恢复优先级，避免“优先级反转”问题\n\n\n🔧 示例用途：\nxSemaphoreTake(mutex, portMAX_DELAY);  // 上锁 // 访问共享资源... xSemaphoreGive(mutex);                 // 解锁\n\n4. ✅ 事件组（Event Group）\n用 位(bit) 表示多个事件状态（最多 24 个位）\n\n支持按位等待“任一位”或“所有位”\n\n适合多个状态控制组合，如：\n\nBIT0 表示联网成功\n\nBIT1 表示传感器初始化完成\n\nBIT2 表示时间同步完成\n\n\n\n\n🔧 示例用途：\nxEventGroupSetBits(event_group, BIT0 | BIT2); // 设置位 xEventGroupWaitBits(event_group, BIT0 | BIT2, pdTRUE, pdTRUE, portMAX_DELAY); // 等待两个事件位\n\n5. ✅ 任务通知（Task Notification）\n每个任务自带一个“私有”通知通道\n\n可传一个 uint32_t 值\n\n效率最高，占用最少\n\n适合一对一通知，不能一对多\n\n\n🔧 示例用途：\nxTaskNotify(task_handle, 1234, eSetValueWithOverwrite); // 发送通知值 xTaskNotifyWait(0, 0, &amp;value, portMAX_DELAY);            // 等待并接收通知值\n\n🧪 使用建议总结\n\n\n如果你要…\n用这个机制\n\n\n\n任务&#x2F;中断传输数据结构\n✅ 队列 Queue\n\n\n仅通知某事件发生\n✅ 二值信号量\n\n\n控制资源（如 I2C）访问顺序\n✅ 互斥锁 Mutex\n\n\n等待多个条件状态完成\n✅ 事件组 Event Group\n\n\n轻量、一对一传信号&#x2F;值\n✅ 任务通知 Task Notification\n\n\n\n📌 提示\n\n\n注意点\n说明\n\n\n\n队列最耗资源\n占用内存（需内部数组存放数据）\n\n\n任务通知最快\n每个任务只能有一个通知通道，适合一对一\n\n\n事件组不能传值\n只能用位来表示事件状态\n\n\n信号量没有值\n不能附带数据，只是“信号”\n\n\n互斥锁专用于资源保护\n不建议用作通用同步机制\n\n\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","FreeRTOS"]},{"title":"4.事件组和直达任务通知","url":"/2025/05/20/1%E3%80%81freertos/4%E3%80%81%E4%BA%8B%E4%BB%B6%E7%BB%84%E5%92%8C%E7%9B%B4%E8%BE%BE%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A54/","content":"事件组事件位：用于指示事件是否发生，事件位通常称为事件标志；事件组：就是一组事件位。事件组中的事件位通过位编号来引用；\n![[Pasted image 20250518153023.png]]\n//创建一个事件组，返回事件组句柄，失败返回NULLEventGroupHandle_t xEventGroupCreate(void);//等待事件组中某个标志位，用返回值以确定哪些位已完成设置EventBits_t xEventGroupWaitBits(\tconst EventGroupHandle_t xEventGroup,//事件组句柄\tconst EventBits_t uxBitsToWaitFor,//哪些位需要等待\tconst BaseType_t xClearOnExit,//是否自动清除标志位\tconst BaseType_t xWaitForAllBits,//是否等待的标志位都成功了才返回\tTickType_t xTicksToWait//最大阻塞时间);//设置标志位EventBits xEventGroupSetBits(\tEventGroupHandle_t xEventGroup,//事件组句柄\tconst EventBits_t uxBitsToSet//设置哪个位)//清除标志位EventBits xEventGroupClearBits(\tEventGroupHandle_t xEventGroup,//事件组句柄\tconst EventBits_t uxBitsToClear//清除的标志位)\n\n实例代码#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/event_groups.h&quot;#include &quot;freertos/task.h&quot;#include &quot;esp_log.h&quot;// 定义事件位（位掩码）#define NUM0_BIT BIT0  // 即 0x01，事件位0#define NUM1_BIT BIT1  // 即 0x02，事件位1// 定义一个事件组句柄static EventGroupHandle_t test_event;// 任务A：每隔1秒设置一次事件位void taskA(void *param)&#123;    while (1)    &#123;        // 设置事件位 BIT0        xEventGroupSetBits(test_event, NUM0_BIT);        vTaskDelay(pdMS_TO_TICKS(1000));  // 延时1秒        // 设置事件位 BIT1        xEventGroupSetBits(test_event, NUM1_BIT);        vTaskDelay(pdMS_TO_TICKS(1000));  // 延时1秒    &#125;&#125;// 任务B：等待事件位的触发void taskB(void *param)&#123;    EventBits_t ev;    while (1)    &#123;        // 等待事件位 BIT0 或 BIT1 被设置，超时为5000毫秒        // pdTRUE 表示接收到事件后清除这些位        // pdFALSE 表示“或”逻辑，只要任意一位被置位就满足条件        ev = xEventGroupWaitBits(test_event, NUM0_BIT | NUM1_BIT, pdTRUE, pdFALSE, pdMS_TO_TICKS(5000));        // 检查是哪一个事件位被设置了        if (ev &amp; NUM0_BIT)        &#123;            ESP_LOGI(&quot;ev&quot;, &quot;get BIT0 event&quot;);        &#125;        if (ev &amp; NUM1_BIT)        &#123;            ESP_LOGI(&quot;ev&quot;, &quot;get BIT1 event&quot;);        &#125;    &#125;&#125;// 主函数void app_main(void)&#123;    // 创建事件组    test_event = xEventGroupCreate();    // 创建任务A：设置事件位    xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 3, NULL, 1);    // 创建任务B：等待事件位    xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 3, NULL, 1);&#125;\n\n\n\n\n内容\n解释\n\n\n\nEventGroupHandle_t\n事件组类型，用于管理多个事件位\n\n\nxEventGroupSetBits()\n设置一个或多个事件位\n\n\nxEventGroupWaitBits()\n等待某些事件位被置位\n\n\npdTRUE（清除标志）\n指定等待完成后是否自动清除这些事件位\n\n\npdFALSE（等待所有位）\n指定是否等待“所有位”置位（pdTRUE）或“任意一位”置位（pdFALSE）\n\n\n![[Pasted image 20250518155912.png]]\n\n\n\n\n直达任务通知每个RTOS任务都有一个任务通知组。每条任务通知 都有“挂起”或“非挂起”的通知状态，以及一个32位通知值。直达任务通知是直接发送至任务的事件，而不是通过中间对象（如队列、事件组或信号量）间接发送至任务的事件。向任务发送“直达任务通知”会将目标任务通知设为“挂起”状态（此挂起不是挂起任务）。\n用直达任务通知的时候，无需再初始化或新建其他对象句柄，直接使用任务句柄来操作通知的发送。说白了就是两个任务间可以直接通信，而不是像队列一样通过变量间接完成。\n![[Pasted image 20250518154256.png]]\n//用于将通知直接诶发送到RTOS任务并可能取消该任务的阻塞状态BaseType_t xTaskNotify(\tTaskHandle_t xTaskToNotify,//要通知的任务句柄\tuint32_t ulValue,//携带的通知值\teNotifyAction eAction,//执行的操作);//等待接收任务通知BaseType_t xTaskNotifyWait(\tuint32_t ulBitsToClearOnEntry,//进入函数清除的通知值位\tuint32_t ulBitsToClearOnExit,//退出函数清除的通知值位\tuint32_t * pulNotificationValue,//通知值\tTickType_t xTicksToWait//等待时长);\n\n\n实例代码#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/event_groups.h&quot;  // 此处未使用 event_groups，可省略#include &quot;freertos/task.h&quot;#include &quot;esp_log.h&quot;// 声明两个任务句柄static TaskHandle_t taskA_handle;static TaskHandle_t taskB_handle;// 任务A：定时向任务B发送任务通知void taskA(void *param)&#123;    uint32_t value = 0;  // 通知的值    vTaskDelay(pdMS_TO_TICKS(200));  // 启动延时 200ms，确保任务B已经创建    while (1)    &#123;        // 向任务B发送通知，附带 value 值        // 使用 eSetValueWithoutOverwrite 模式：如果任务B未接收上次通知，则不覆盖        xTaskNotify(taskB_handle, value, eSetValueWithoutOverwrite);        vTaskDelay(pdMS_TO_TICKS(1000));  // 每秒发送一次通知        value++;  // 通知值递增    &#125;&#125;// 任务B：等待并接收任务通知值，打印日志void taskB(void *param)&#123;    uint32_t value;  // 接收到的通知值    while (1)    &#123;        // 等待任务通知，阻塞时间为 portMAX_DELAY（即永久阻塞直到收到通知）        // 第一个参数：不清除任何已有的通知位        // 第二个参数：清除所有通知位        // 第三个参数：接收通知值        xTaskNotifyWait(0x00, ULONG_MAX, &amp;value, portMAX_DELAY);        // 打印接收到的通知值        ESP_LOGI(&quot;ev&quot;, &quot;notify wait value:%lu&quot;, value);    &#125;&#125;// 主函数void app_main(void)&#123;    // 创建任务A，并将任务句柄赋值给 taskA_handle    xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 3, &amp;taskA_handle, 1);    // 创建任务B，并将任务句柄赋值给 taskB_handle（必须，任务A要用到）    xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 3, &amp;taskB_handle, 1);&#125;\n\n\n\n![[Pasted image 20250518163208.png]]\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","FreeRTOS"]},{"title":"3.信号量","url":"/2025/05/20/1%E3%80%81freertos/3%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F3/","content":"信号量![[Pasted image 20250518115216.png]]\n//创建二值信号量，成功则返回信号量句柄（二值信号量最大只有1个）SemaphoreHandle_t xSemaphoreCreateBinary(void);//创建计数信号量，成功则返回信号量句柄SemaphoreHandle_t xSemaphoreCreateCounting(\tUBseType_t uxMaxCount,//最大信号量数\tUBseType_t uxInitialCount//初始信号量数);//获取一个信号量，如果获得信号量，则返回pdTURExSemaphoreTake(\tSemaphoreHandle_t xSemaphore,//信号量句柄\tTickType_t xTicksTowait//等待时间);//释放一个信号量xSemaphoreGive(SemaphoreHandle_t xSemaphore);//信号量句柄//删除信号量xSemaphoreDelete(SemaphoreHandle_t xSemaphore);//信号量句柄\n\n实例代码#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;      // FreeRTOS 主头文件#include &quot;freertos/task.h&quot;          // 任务管理#include &quot;freertos/semphr.h&quot;        // 信号量相关#include &quot;esp_log.h&quot;                // ESP-IDF 日志模块// 定义一个二值信号量句柄SemaphoreHandle_t bin_sem;// 任务A：周期性释放信号量void taskA(void* param)&#123;    while (1)    &#123;        // 向信号量发送“释放”信号，允许其他任务继续执行        xSemaphoreGive(bin_sem);        // 每隔1秒释放一次        vTaskDelay(pdMS_TO_TICKS(1000));    &#125;&#125;// 任务B：等待信号量被释放后执行void taskB(void *param)&#123;    while (1)    &#123;        // 尝试获取信号量，如果没拿到就阻塞（无限等待）        if(pdTRUE == xSemaphoreTake(bin_sem, portMAX_DELAY))        &#123;            // 成功获取信号量后打印信息            ESP_LOGI(&quot;bin&quot;, &quot;task B take binsem success&quot;);        &#125;    &#125;&#125;// 系统入口函数void app_main(void)&#123;    // 创建一个初始为空的二值信号量    bin_sem = xSemaphoreCreateBinary();    // 创建任务A，运行在核心1，优先级为3    xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 3, NULL, 1);    // 创建任务B，运行在核心1，优先级为4（高于任务A）    xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 4, NULL, 1);&#125;\n\n\n\n互斥锁![[Pasted image 20250518105647.png]]优先级：A&gt;B&gt;C，任务C与任务A优先级翻转，先C后B\n实例代码#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;freertos/semphr.h&quot;#include &quot;esp_log.h&quot;#include &quot;driver/gpio.h&quot;#include &quot;dht11.h&quot;  // DHT11 传感器头文件，需自行实现或引用// 定义一个互斥信号量句柄SemaphoreHandle_t dht11_mutex;// 任务A，读取温湿度并打印void taskA(void* param) &#123;    int temp, humidity;    while (1) &#123;        // 请求互斥信号量，独占访问DHT11        xSemaphoreTake(dht11_mutex, portMAX_DELAY);        // 延时500ms，确保DHT11准备好        vTaskDelay(pdMS_TO_TICKS(500));        // 如果成功读取DHT11数据        if (DHT11_StartGet(&amp;temp, &amp;humidity)) &#123;            // 打印温度和湿度（温度以整数形式除以10）            ESP_LOGI(&quot;dht11&quot;, &quot;taskA--&gt;temp:%d, humidity:%d%%&quot;, temp / 10, humidity);        &#125;        // 释放互斥信号量        xSemaphoreGive(dht11_mutex);        // 任务延时1000ms        vTaskDelay(pdMS_TO_TICKS(1000));    &#125;&#125;// 任务B，功能与任务A相同void taskB(void *param) &#123;    int temp, humidity;    while (1) &#123;        xSemaphoreTake(dht11_mutex, portMAX_DELAY);        vTaskDelay(pdMS_TO_TICKS(500));        if (DHT11_StartGet(&amp;temp, &amp;humidity)) &#123;            ESP_LOGI(&quot;dht11&quot;, &quot;taskB--&gt;temp:%d, humidity:%d%%&quot;, temp / 10, humidity);        &#125;        xSemaphoreGive(dht11_mutex);        vTaskDelay(pdMS_TO_TICKS(1000));    &#125;&#125;// 主函数void app_main(void) &#123;    // 创建一个二值信号量（用于互斥访问）    dht11_mutex = xSemaphoreCreateBinary();    // 注意：创建二值信号量后需要先释放一次，否则不能使用    xSemaphoreGive(dht11_mutex);    // 创建任务A，绑定到核心1，优先级为3，堆栈大小为2048字节    xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 3, NULL, 1);    // 创建任务B，绑定到核心1，优先级为3，堆栈大小为2048字节    xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 3, NULL, 1);&#125;\n\n\n\n\n\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","FreeRTOS"]},{"title":"2.1中断理论","url":"/2025/05/21/2%E3%80%81%E5%A4%96%E8%AE%BE%E6%95%99%E7%A8%8B/2%E3%80%81%E4%B8%AD%E6%96%AD/2.1%20%E4%B8%AD%E6%96%AD%E7%90%86%E8%AE%BA/","content":"![[Pasted image 20250519111748.png]]![[Pasted image 20250519111949.png]]\n![[Pasted image 20250519112416.png]]一般不用全局中断\n![[Pasted image 20250519112632.png]]二选一，一般下面方式。\n![[Pasted image 20250519112809.png]]记得安装中断服务![[Pasted image 20250519113952.png]]\n![[Pasted image 20250519114031.png]]\n注意：![[Pasted image 20250519114617.png]]\n![[Pasted image 20250519115303.png]]![[Pasted image 20250519115319.png]]\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","INTR"]},{"title":"1.1 GPIO理论","url":"/2025/05/21/2%E3%80%81%E5%A4%96%E8%AE%BE%E6%95%99%E7%A8%8B/1%E3%80%81GPIO/1.1%20GPIO%E7%90%86%E8%AE%BA/","content":"ESP32 系列芯片中，引脚定义是从 GPIO0~GPIO48，一共有 49 个 IO 引脚，ESP32-S3 官方文档给出的是 45 个 GPIO 可用，但其实每个型号 的芯片上对 GPIO 的使用都有些细微差异，并且有些引脚其实并没有被引出，所以我们能够使用的引脚也 只有 33 个。\n![[Pasted image 20250519100433.png]]\n\nGPIO0 、 GPIO3 、GPIO45 、 GPIO46在系统启动的时候需被当做了 Strapping 管脚，有特殊含义， 所以在启动阶段不能使用，但启动完毕之后是可用的；\nGPIO19 和 GPIO20 是 USB 固定引脚，如果使用 USB 功能的话只能用这两个引脚，如果不使用 USB 功能，这两个引脚可以随意使用；\nGPIO43 和 GPIO44 被定义为 UART0 ，作为串口0对外输出信息，同时还具备了固件烧录的功能，所 以如果使用 REPL 模式的情况下，这两个引脚是不能使用的，如果使用 main 模式则可以考虑启用；\nGPIO26~GPIO32， 这一组引脚被用作片内的 Flash 或者是 PSRAM 通讯用，外部不能使用\nGPIO33~GPIO38，MooPi-ES 系列核心板中有几个型号，这几个引脚用作了扩展 Flash 的引脚，如果 被占用，则这几个引脚也是不可用的。\n\n\n![[Pasted image 20250519132900.png]]\n引脚整体说明GPIO36: 只能作为输入不能输出; ADC1通道0的采集引脚\nGPIO39: 只能作为输入不能输出; ADC1通道3的采集引脚\nGPIO34: 只能作为输入不能输出; ADC1通道6的采集引脚\nGPIO35: 只能作为输入不能输出; ADC1通道7的采集引脚\nGPIO32: 输入输出IO; ADC1通道4的采集引脚; 触摸检测通道9\nGPIO33: 输入输出IO; ADC1通道5的采集引脚; 触摸检测通道8\nGPIO25: 输入输出IO; ADC2通道8的采集引脚; DAC输出通道1\nGPIO26: 输入输出IO; ADC2通道9的采集引脚; DAC输出通道2\nGPIO27: 输入输出IO; ADC2通道7的采集引脚; 触摸检测通道7\nGPIO14: 上电默认输出一个高脉冲(600ms);输入输出IO; ADC2通道6的采集引脚; 触摸检测通道6; JTMS; HSPI_CLK; HS2_CLK; SD_CLK\nGPIO12: 模组启动时必须保证为低电平,内部默认下拉,;输入输出IO; ADC2通道5的采集引脚; 触摸检测通道5; JTDI; HSPI_Q; HS2_DATA2; SD_DATA2\nGPIO13: 输入输出IO; ADC2通道4的采集引脚; 触摸检测通道4; JTCLK; HSPI_D; HS2_DATA3; SD_DATA3\nGPIO9:   连接ESP32内部SPI闪存,用户不要使用其作为普通IO.可以连接外部Flash或SRAM  \nGPIO10: 连接ESP32内部SPI闪存,用户不要使用其作为普通IO.可以连接外部Flash或SRAM  \nGPIO11: 连接ESP32内部SPI闪存,作为闪存的片选,用户不要使用.\nGPIO6:  连接ESP32内部SPI闪存,用户不要使用其作为普通IO.可以连接外部Flash或SRAM\nGPIO7:  连接ESP32内部SPI闪存,用户不要使用其作为普通IO.可以连接外部Flash或SRAM  \nGPIO8:  连接ESP32内部SPI闪存,用户不要使用其作为普通IO.可以连接外部Flash或SRAM  \nGPIO15: 输入输出IO; ADC2通道3的采集引脚; 触摸检测通道3; JTDO; HSPI_CS; HS2_CMD; SD_CMD\nGPIO2:  输入输出IO; ADC2通道2的采集引脚; 触摸检测通道2; HSPI_WP; HS2_DATA0; SD_DATA0\nGPIO0:  模组启动之前保持低电平进入程序下载模式;输入输出IO; ADC2通道1的采集引脚; 触摸检测通道1; \nGPIO4:  输入输出IO; ADC2通道0的采集引脚; 触摸检测通道0; HSPI_HD; HS2_DATA1; \nGPIO16:  输入输出IO; HS1_DATA4; USART2_RX(默认AT指令固件通信引脚);\nGPIO17:  输入输出IO; HS1_DATA5; USART2_TX(默认AT指令固件通信引脚);\nGPIO5:   上电默认输出一个低脉冲(200ms左右),正常运行输出高电平; 输入输出IO; VSPI_CS; HS1_DATA6;\nGPIO18:  输入输出IO; VSPI_CLK; HS1_DATA7;\nGPIO19:  输入输出IO; VSPI_Q;\nGPIO21:  输入输出IO; VSPI_HD;\nGPIO3:    输入输出IO; USART0_RX;(程序串口通信下载口)  \nGPIO1:    输入输出IO; USART0_TX;(程序串口通信下载口)\nGPIO23:  输入输出IO; VSPI_D; HS1_STROBE;\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","GPIO"]},{"title":"2.2按键中断点灯","url":"/2025/05/21/2%E3%80%81%E5%A4%96%E8%AE%BE%E6%95%99%E7%A8%8B/2%E3%80%81%E4%B8%AD%E6%96%AD/2.2%20%E6%8C%89%E9%94%AE%E4%B8%AD%E6%96%AD%E7%82%B9%E7%81%AF/","content":"#include &lt;stdio.h&gt;#include &quot;driver/gpio.h&quot;          // GPIO 控制头文件#include &quot;freertos/FreeRTOS.h&quot;    // FreeRTOS 相关头文件（虽然本代码没用到任务）#include &quot;esp_log.h&quot;              // 用于日志打印（此代码中未使用）/** * @brief GPIO 中断服务函数，当 GPIO 口电平发生变化时触发 * @param args 传入的参数，是中断来源的 GPIO 编号（通过强转传入） */static void gpio_isr_handle(void *args)&#123;    int io_num = (int)args;                      // 获取产生中断的 GPIO 编号    int level = gpio_get_level(GPIO_NUM_9);      // 读取 LED 当前电平    gpio_set_level(GPIO_NUM_9, !level);          // LED 状态取反，实现按键切换灯状态    // 下面是原计划对不同按键做不同处理的代码（已注释）    // if(io_num == 0)&#123;    //     // 按键0按下 -&gt; 开灯（低电平）    //     gpio_set_level(GPIO_NUM_9, 0);    // &#125;    // else if(io_num == 1)&#123;    //     // 按键1按下 -&gt; 关灯（高电平）    //     gpio_set_level(GPIO_NUM_9, 1);    // &#125;&#125;void app_main(void)&#123;    // === 1. 配置按键 GPIO ===    gpio_config_t key_cfg = &#123;        .pin_bit_mask = 1ULL &lt;&lt; 1,             // 配置 GPIO1（按键）对应的位掩码        .mode = GPIO_MODE_INPUT,               // 设置为输入模式        .pull_up_en = GPIO_PULLUP_ENABLE,      // 使能内部上拉电阻（适用于按键接 GND 的方式）        .intr_type = GPIO_INTR_NEGEDGE,        // 设置为下降沿中断（按键按下）        // 可选：上升沿 / 电平触发 / 双边沿触发等    &#125;;    ESP_ERROR_CHECK(gpio_config(&amp;key_cfg));    // 应用按键 GPIO 配置    // === 2. 安装 GPIO 中断服务 ===    // 中断服务需要加载到 IRAM（快速内存区域），这样中断时可立即响应    gpio_install_isr_service(ESP_INTR_FLAG_IRAM);    // === 3. 绑定中断服务函数到指定引脚 ===    // 当 GPIO1 产生中断时，调用 gpio_isr_handle 函数，并传入 GPIO 编号    gpio_isr_handler_add(GPIO_NUM_1,            // GPIO1：按键1                         gpio_isr_handle,       // 中断服务函数                         (void *)GPIO_NUM_1);   // 参数，转为 void* 传入                             gpio_isr_handler_add(GPIO_NUM_0,            // GPIO0：按键0                         gpio_isr_handle,       // 中断服务函数                         (void *)GPIO_NUM_0);   // 参数    // === 4. 配置 LED 输出引脚 ===    gpio_config_t led_cfg = &#123;        .pin_bit_mask = 1ULL &lt;&lt; 9,              // GPIO9 作为输出口（控制 LED）        .mode = GPIO_MODE_OUTPUT,               // 输出模式    &#125;;    gpio_config(&amp;led_cfg);                      // 应用 LED GPIO 配置    gpio_set_level(GPIO_NUM_9, 1);              // 初始化 LED 关闭（高电平熄灭）&#125;\n\n\n\n🧠 补充说明\ngpio_isr_handle() 中使用 gpio_get_level(GPIO_NUM_9) 来读取当前 LED 状态，再用 !level 取反，实现“按一次换一次状态”的 切换功能。\n\ngpio_isr_handler_add() 可绑定多个引脚到同一个中断函数（通过参数区分来源）。\n\ngpio_install_isr_service() 只能调用一次，否则会报错。\n\nESP_INTR_FLAG_IRAM 是推荐的中断标志，确保中断服务函数在 RAM 中，执行更快更安全。\n\n\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","INTR"]},{"url":"/2025/05/23/2%E3%80%81%E5%A4%96%E8%AE%BE%E6%95%99%E7%A8%8B/3%E3%80%81%E8%A7%A6%E6%91%B8/3.2%20%E8%A7%A6%E6%91%B8%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86/","content":"触摸传感器使用顺序1.初始化触摸传感器，\n2.对触摸传感器和引脚进行配置，\n3.启动FSM（有限状态机）\n4.采集原始数据\n5.卸载触摸传感器\n初始化触摸传感器![[Pasted image 20250519135238.png]]\nFSM有限状态机![[Pasted image 20250519135837.png]]\n示例代码#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;     // FreeRTOS 基础头文件#include &quot;freertos/task.h&quot;         // FreeRTOS 任务相关#include &quot;driver/touch_sensor.h&quot;   // ESP32 触摸传感器驱动头文件#include &quot;esp_log.h&quot;               // ESP 日志系统，用于打印调试信息#define TAG &quot;TOUCH&quot;  // 设置日志打印时的模块标签void app_main(void)&#123;    // === 1. 初始化触摸传感器模块 ===    // 这一步会初始化 ESP32 内部所有触摸相关硬件资源    touch_pad_init();    // === 2. 配置某个触摸传感器通道 ===    // 这里只使用 TOUCH_PAD_NUM11（也就是 GPIO11）作为触摸输入    // 该函数会自动为此通道设置默认阈值    touch_pad_config(TOUCH_PAD_NUM11);    // === 3. 启动 FSM（有限状态机）处理机制 ===    // FSM 会定时触发触摸采样动作，由硬件内部实现    touch_pad_set_fsm_mode(TOUCH_FSM_MODE_TIMER);  // 使用内部定时器方式采样    touch_pad_fsm_start();                         // 启动触摸采样机制    // === 4. 循环读取触摸通道的原始电容值 ===    while (1)    &#123;        uint32_t raw_data;   // 存放读取到的原始值        // 读取指定触摸通道的原始电容值（未经过滤和计算）        touch_pad_read_raw_data(TOUCH_PAD_NUM11, &amp;raw_data);        // 打印读取到的原始值，用于观察是否被触摸        ESP_LOGI(TAG, &quot;原始值: %ld&quot;, raw_data);        // 延时 100 毫秒        vTaskDelay(pdMS_TO_TICKS(100));    &#125;    // === 5. 停止 FSM 状态机（通常在程序退出前使用）===    touch_pad_fsm_stop();    // === 6. 卸载触摸传感器驱动，释放资源 ===    touch_pad_deinit();&#125;\n\n\n\n\n\n\n"},{"url":"/2025/05/23/2%E3%80%81%E5%A4%96%E8%AE%BE%E6%95%99%E7%A8%8B/3%E3%80%81%E8%A7%A6%E6%91%B8/3.3%20%E8%A7%A6%E6%91%B8%E4%B8%AD%E6%96%AD/","content":"![[Pasted image 20250519205057.png]]1、初始化触摸传感器\n2、配置触摸传感器\n3、设置触摸中断触发的阈值\n4、注册中断触发函数\n5、起用中断，并设置中断触发条件\n6、配置和启动 FSM\n7、等在中断触发\n注册中断服务函数![[Pasted image 20250519205834.png]]\n触发阈值![[Pasted image 20250519214150.png]]\n基准值![[Pasted image 20250519214234.png]]\n"},{"url":"/2025/05/23/2%E3%80%81%E5%A4%96%E8%AE%BE%E6%95%99%E7%A8%8B/3%E3%80%81%E8%A7%A6%E6%91%B8/3.1%20%E8%A7%A6%E6%91%B8%E4%BC%A0%E6%84%9F%E5%99%A8%E7%90%86%E8%AE%BA/","content":"触摸传感器的种类![[Pasted image 20250519132533.png]]\nESP32-S3中的电容触摸传感器![[Pasted image 20250519132630.png]]\n触摸传感器使用方法![[Pasted image 20250519132658.png]]\n"},{"title":"1.2.1 驱动OLED-无freertos","url":"/2025/05/21/2%E3%80%81%E5%A4%96%E8%AE%BE%E6%95%99%E7%A8%8B/1%E3%80%81GPIO/1.2.1%20%E9%A9%B1%E5%8A%A8LED-%E6%97%A0freertos/","content":"GPIO 输出输出配置![[Pasted image 20250519103522.png]]\n![[Pasted image 20250519103658.png]]\n#include &lt;stdio.h&gt;#include &quot;driver/gpio.h&quot;#include &quot;freertos/FreeRTOS.h&quot;void app_main(void)&#123;    // //1.配置GPIO    // gpio_config_t gpio_cfg = &#123;    //     .pin_bit_mask = 1ULL &lt;&lt; 9,      //pin掩码    //     .mode = GPIO_MODE_OUTPUT,    // &#125;;    // gpio_config(&amp;gpio_cfg);             //配置    gpio_reset_pin(GPIO_NUM_9);    gpio_set_direction(GPIO_NUM_9, GPIO_MODE_OUTPUT);    while (1)    &#123;        /* code */        gpio_set_level(GPIO_NUM_9, 0);         //点亮        vTaskDelay(pdMS_TO_TICKS(1000));        gpio_set_level(GPIO_NUM_9, 1);         //熄灭        vTaskDelay(pdMS_TO_TICKS(1000));    &#125;&#125;\n\n主要区别对比​\n\n\n特性\ngpio_config\ngpio_reset_pin + gpio_set_direction\n\n\n\n​配置方式​\n批量配置（可配置多个GPIO）\n单个GPIO逐个配置\n\n\n​功能支持​\n支持模式、上拉&#x2F;下拉、中断等\n仅支持方向（输入&#x2F;输出）\n\n\n​灵活性​\n更高（可配置更多参数）\n较低（仅方向）\n\n\n​适用场景​\n复杂GPIO配置（多引脚、特殊功能）\n简单GPIO方向设置\n\n\nGPIO 驱动能力![[Pasted image 20250519110820.png]]![[Pasted image 20250519110925.png]]\nGPIO输入示例代码#include &lt;stdio.h&gt;#include &quot;driver/gpio.h&quot;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;esp_log.h&quot;void app_main(void)&#123;    //1.配置GPIO    gpio_config_t gpio_cfg = &#123;        .pin_bit_mask = 1ULL &lt;&lt; 1,      //pin掩码        .mode = GPIO_MODE_INPUT,        .pull_up_en = GPIO_PULLUP_ENABLE,    &#125;;    ESP_ERROR_CHECK(gpio_config(&amp;gpio_cfg));              //配置    gpio_dump_io_configuration(stdout, 1ULL&lt;&lt;1);    while (1)    &#123;        int level = gpio_get_level(GPIO_NUM_1);                ESP_LOGE(&quot;TAG&quot;, &quot;GPIO1 input level:%d&quot;, level);        ESP_LOGW(&quot;TAG&quot;, &quot;GPIO1 input level:%d&quot;, level);        ESP_LOGI(&quot;TAG&quot;, &quot;GPIO1 input level:%d&quot;, level);        ESP_LOGD(&quot;TAG&quot;, &quot;GPIO1 input level:%d&quot;, level);        ESP_LOGV(&quot;TAG&quot;, &quot;GPIO1 input level:%d&quot;, level);        vTaskDelay(pdMS_TO_TICKS(1000));    &#125;&#125;\n\n![[Pasted image 20250519111241.png]]\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","GPIO"]},{"title":"1.2.1 驱动OLED-有freertos","url":"/2025/05/21/2%E3%80%81%E5%A4%96%E8%AE%BE%E6%95%99%E7%A8%8B/1%E3%80%81GPIO/1.2.2%20%E9%A9%B1%E5%8A%A8LED-%E6%9C%89freertos/","content":"#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;driver/gpio.h&quot;// 定义三个LED对应的GPIO引脚#define LED_GPIO_1 GPIO_NUM_2  // 第一个LED连接到GPIO2/​**​ * @brief 控制LED闪烁的任务函数（周期500ms） *  * @param param 参数，传递LED对应的GPIO引脚号 */void led_run_task(void *param)&#123;    int gpio_level = 0;          // 初始电平状态（0=低电平，1=高电平）    gpio_num_t gpio_num = (gpio_num_t)param;  // 将参数转换为GPIO引脚号    while (1)  // 无限循环    &#123;        gpio_level = gpio_level ? 0 : 1;  // 切换电平状态（取反）        gpio_set_level(gpio_num, gpio_level);  // 设置GPIO电平        vTaskDelay(pdMS_TO_TICKS(500));  // 延时500ms（任务阻塞）    &#125;&#125;/​**​ * @brief 主函数，程序入口 */void app_main(void)&#123;    // 配置GPIO为输出模式    gpio_config_t led_cfg = &#123;        .pin_bit_mask = (1 &lt;&lt; LED_GPIO_1),  // 位掩码设置GPIO        .pull_up_en = GPIO_PULLUP_DISABLE,  // 禁用上拉电阻        .pull_down_en = GPIO_PULLDOWN_DISABLE,  // 禁用下拉电阻        .mode = GPIO_MODE_OUTPUT,  // 设置为输出模式        .intr_type = GPIO_INTR_DISABLE,  // 禁用中断    &#125;;    gpio_config(&amp;led_cfg);  // 应用GPIO配置    xTaskCreatePinnedToCore(led_run_task, &quot;led1&quot;, 2048, (void *)LED_GPIO_1, 3, NULL, 1);  // 任务1：500ms周期&#125;\n\n\n\n\nPWM调光#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;        // FreeRTOS 系统头文件#include &quot;freertos/task.h&quot;            // 任务管理函数#include &quot;driver/gpio.h&quot;              // GPIO 操作函数#include &quot;driver/ledc.h&quot;              // LED PWM（LEDC）控制函数// 定义 LED 所连接的 GPIO 引脚编号#define LED_GPIO GPIO_NUM_2// 定义事件组中两个事件位，分别表示占空比非零（LED亮）和占空比为零（LED灭）#define FULL_EV_BIT BIT0     // 事件位0：占空比非零#define EMPTY_EV_BIT BIT1    // 事件位1：占空比为零// 定义事件组句柄，用于任务间同步static EventGroupHandle_t ledc_event_handle;/** * @brief LEDC 渐变完成中断回调函数（从中断中调用） * @param param  包含占空比等信息的回调参数结构体 * @param user_arg  用户参数（此处未使用） * @return 若唤醒高优先级任务，返回 true */bool IRAM_ATTR ledc_finish_cb(const ledc_cb_param_t *param, void *user_arg)&#123;    BaseType_t taskWorken;  // 记录是否需要切换上下文    if(param-&gt;duty)  // 如果占空比非零，说明 LED 点亮    &#123;        // 设置 FULL_EV_BIT 事件位，通知任务 LED 亮了        xEventGroupSetBitsFromISR(ledc_event_handle, FULL_EV_BIT, &amp;taskWorken);    &#125;    else  // 占空比为 0，说明 LED 熄灭    &#123;        // 设置 EMPTY_EV_BIT 事件位，通知任务 LED 灭了        xEventGroupSetBitsFromISR(ledc_event_handle, EMPTY_EV_BIT, &amp;taskWorken);    &#125;    return taskWorken;  // 若有高优先级任务被唤醒，则返回 true&#125;/** * @brief 控制 LED 呼吸效果的任务 * @param param 参数（此处未使用） */void led_run_task(void *param)&#123;    EventBits_t ev;  // 保存等待到的事件位    while (1)    &#123;        // 等待 FULL_EV_BIT 或 EMPTY_EV_BIT 事件，超时时间 5000ms        // pdTRUE 表示等待到事件后自动清除，pdFALSE 表示任一事件位即可返回        ev = xEventGroupWaitBits(ledc_event_handle, FULL_EV_BIT | EMPTY_EV_BIT,                                 pdTRUE, pdFALSE, pdMS_TO_TICKS(5000));        if(ev &amp; FULL_EV_BIT)        &#123;            // 如果 LED 处于亮的状态（占空比非0），开始执行灭灯过程            ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 0, 2000);  // 渐变至占空比0（灭），耗时2000ms            ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT); // 非阻塞启动渐变        &#125;        if(ev &amp; EMPTY_EV_BIT)        &#123;            // 如果 LED 处于灭的状态，开始执行亮灯过程            ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 8191, 2000); // 渐变至最大亮度            ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT); // 非阻塞启动渐变        &#125;        // 注册渐变完成的回调函数        // 注：理论上只需注册一次，可移到初始化阶段        ledc_cbs_t cbs = &#123;            .fade_cb = ledc_finish_cb,   // 设置渐变完成回调        &#125;;        ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &amp;cbs, NULL);    &#125;&#125;/** * @brief 主程序入口，进行各项初始化并创建任务 */void app_main(void)&#123;    // GPIO 初始化，用于控制 LED    gpio_config_t led_cfg = &#123;        .pin_bit_mask = 1 &lt;&lt; LED_GPIO,         // 要配置的引脚掩码        .pull_up_en = GPIO_PULLUP_DISABLE,     // 禁用上拉        .pull_down_en = GPIO_PULLDOWN_DISABLE, // 禁用下拉        .mode = GPIO_MODE_OUTPUT,              // 设置为输出模式        .intr_type = GPIO_INTR_DISABLE,        // 禁用中断    &#125;;    gpio_config(&amp;led_cfg);  // 应用 GPIO 配置    // 初始化 LEDC 定时器    ledc_timer_config_t ledc_timer = &#123;        .speed_mode = LEDC_LOW_SPEED_MODE,     // 设置为低速模式（对应较慢频率）        .timer_num = LEDC_TIMER_0,             // 使用定时器0        .clk_cfg = LEDC_AUTO_CLK,              // 自动选择时钟源        .freq_hz = 5000,                       // PWM 频率为 5kHz        .duty_resolution = LEDC_TIMER_13_BIT,  // 占空比分辨率为13位，最大值8191    &#125;;    ledc_timer_config(&amp;ledc_timer);  // 应用定时器配置    // 初始化 LEDC 通道    ledc_channel_config_t ledc_channel = &#123;        .speed_mode = LEDC_LOW_SPEED_MODE,     // 同样为低速模式        .channel = LEDC_CHANNEL_0,             // 使用通道0        .timer_sel = LEDC_TIMER_0,             // 选择上面配置的定时器        .gpio_num = LED_GPIO,                  // 指定输出的GPIO引脚        .duty = 0,                             // 初始占空比为0（LED熄灭）        .intr_type = LEDC_INTR_DISABLE,        // 不使用通道中断    &#125;;    ledc_channel_config(&amp;ledc_channel);  // 应用通道配置    // 安装 LED 渐变功能，使能软件渐变    ledc_fade_func_install(0);    // 执行初始亮灯渐变：从0 → 8191，耗时2000ms    ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 8191, 2000);    ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT); // 非阻塞启动    // 创建一个事件组，用于回调函数与任务间同步通信    ledc_event_handle = xEventGroupCreate();    // 注册 LED 渐变完成后的回调函数    ledc_cbs_t cbs = &#123;        .fade_cb = ledc_finish_cb,    &#125;;    ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &amp;cbs, NULL);    // 创建一个任务控制 LED 交替亮灭，绑定到 Core 1 执行    xTaskCreatePinnedToCore(led_run_task,     // 任务函数名                            &quot;led1&quot;,           // 任务名称                            2048,             // 任务堆栈大小（字节）                            (void *)LED_GPIO, // 传入参数（未使用）                            3,                // 优先级                            NULL,             // 不保存任务句柄                            1);               // 绑定到 Core 1&#125;\n\n\n\n\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","GPIO"]}]