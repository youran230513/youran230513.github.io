[{"title":"2.队列操作","url":"/2025/05/20/esp-freertos/2%E3%80%81%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C2/","content":"esp32里面跑的是freertos,如果需要传递数据需要使用内部的缓存管理.\n任务间同步RTOS中的同步，是指不同任务之间或者任务与外部事件之间的协同工作方式，确保多个并发执行的任务按照预期的顺序或时机执行。它设计到线程或任务间的通信和协调机制，目的是为了避免数据竞争、解决竞态条件，并确保系统的正确行为。\n互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。\n![[Pasted image 20250518093926.png]]\nQueueHandle_t xQueueCreate(//创建一个队列，成功返回队列句柄\tUBaseType_t uxQueueLength,//队列容量\tUBaseType_t uxltemSize    //每个队列项所占内存的大小（单位是字节）);BaseType_t xQueueSend(//向队列头部发送一个消息\tQueueHandle_t xQueue,//队列句柄\tconst void * pvItemToQueue,//要发送的消息指针\tTickType_t xTicksToWait//等待时间);BaseType_t xQueueSendToBack(//向队列尾部发送一个消息\tQueueHandle_t xQueue,//队列句柄\tconst void * pvItemToQueue,//要发送的消息指针\tTickType_t xTicksToWait//等待时间);BaseType_t xQueueReceive(//从队列接收一条信息\tQueueHandle_t xQueue,//队列句柄\tvoid * const pvBuffer,//指向接收消息缓冲区的指针\tTickType_t xTicksToWait//等待时间);BaseType_t xQueueSendFromISR(//xQueueSend的中断版本\tQueueHandle_t xQueue,//队列句柄\tconst void * pvItemToQueue,//要发送的消息指针\tBaseType_t *pxHigherPriorityTaskWoken//如果发送到队列导致任务解除阻塞，且解除阻塞的任务的优先级高于当前运行的任务，则xQueueSendFromISR会将 *pxHigherPriorityTaskWoken设置为pdTRUE，如果xQueueSendFromISR()将此值设置为pdTRUE，则应在中断退出前要执行请求上下文切换函数);\n\n\n\n实例代码#include &lt;stdio.h&gt;#include &quot;esp_log.h&quot;                 // ESP-IDF 日志模块#include &quot;freertos/FreeRTOS.h&quot;      // FreeRTOS 主头文件#include &quot;freertos/task.h&quot;          // 任务管理相关#include &quot;freertos/queue.h&quot;         // 队列管理相关#include &quot;string.h&quot;                 // 字符串和内存操作// 创建一个队列句柄，用于任务之间的通信QueueHandle_t queue_handle = NULL;// 定义一个结构体，用于传输的数据类型typedef struct&#123;    int value; // 整型数据字段&#125; queue_data_t;// 任务A：从队列中接收数据并打印出来void TaskA(void * param)&#123;    queue_data_t data;    while (1)    &#123;        // 尝试接收队列中的数据，超时时间为100个Tick        if(pdTRUE == xQueueReceive(queue_handle, &amp;data, 100))        &#123;            ESP_LOGI(&quot;queue&quot;, &quot;receive queue value: %d&quot;, data.value);        &#125;        // 若没有数据可读，则会超时后继续下一轮循环    &#125;&#125;// 任务B：每隔1秒向队列中发送数据void TaskB(void * param)&#123;    queue_data_t data;    memset(&amp;data, 0, sizeof(queue_data_t));  // 将结构体初始化为0    while (1)    &#123;        // 向队列中发送数据，超时时间为100个Tick        xQueueSend(queue_handle, &amp;data, 100);        // 任务延时1秒（1000ms）        vTaskDelay(pdMS_TO_TICKS(1000));        // 每次发送后将value加1        data.value++;    &#125;&#125;// 主函数：系统入口点void app_main(void)&#123;    // 创建一个长度为10的队列，每个元素大小为queue_data_t结构体的大小    queue_handle = xQueueCreate(10, sizeof(queue_data_t));    // 创建任务A，运行在核心1上，优先级为3，栈大小2048字节    xTaskCreatePinnedToCore(TaskA, &quot;taskA&quot;, 2048, NULL, 3, NULL, 1);    // 创建任务B，同样运行在核心1上    xTaskCreatePinnedToCore(TaskB, &quot;taskB&quot;, 2048, NULL, 3, NULL, 1);&#125;\n\n\n![[Pasted image 20250518104230.png]]\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","FreeRTOS"]},{"title":"3.信号量","url":"/2025/05/20/esp-freertos/3%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F3/","content":"信号量![[Pasted image 20250518115216.png]]\n//创建二值信号量，成功则返回信号量句柄（二值信号量最大只有1个）SemaphoreHandle_t xSemaphoreCreateBinary(void);//创建计数信号量，成功则返回信号量句柄SemaphoreHandle_t xSemaphoreCreateCounting(\tUBseType_t uxMaxCount,//最大信号量数\tUBseType_t uxInitialCount//初始信号量数);//获取一个信号量，如果获得信号量，则返回pdTURExSemaphoreTake(\tSemaphoreHandle_t xSemaphore,//信号量句柄\tTickType_t xTicksTowait//等待时间);//释放一个信号量xSemaphoreGive(SemaphoreHandle_t xSemaphore);//信号量句柄//删除信号量xSemaphoreDelete(SemaphoreHandle_t xSemaphore);//信号量句柄\n\n实例代码#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;      // FreeRTOS 主头文件#include &quot;freertos/task.h&quot;          // 任务管理#include &quot;freertos/semphr.h&quot;        // 信号量相关#include &quot;esp_log.h&quot;                // ESP-IDF 日志模块// 定义一个二值信号量句柄SemaphoreHandle_t bin_sem;// 任务A：周期性释放信号量void taskA(void* param)&#123;    while (1)    &#123;        // 向信号量发送“释放”信号，允许其他任务继续执行        xSemaphoreGive(bin_sem);        // 每隔1秒释放一次        vTaskDelay(pdMS_TO_TICKS(1000));    &#125;&#125;// 任务B：等待信号量被释放后执行void taskB(void *param)&#123;    while (1)    &#123;        // 尝试获取信号量，如果没拿到就阻塞（无限等待）        if(pdTRUE == xSemaphoreTake(bin_sem, portMAX_DELAY))        &#123;            // 成功获取信号量后打印信息            ESP_LOGI(&quot;bin&quot;, &quot;task B take binsem success&quot;);        &#125;    &#125;&#125;// 系统入口函数void app_main(void)&#123;    // 创建一个初始为空的二值信号量    bin_sem = xSemaphoreCreateBinary();    // 创建任务A，运行在核心1，优先级为3    xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 3, NULL, 1);    // 创建任务B，运行在核心1，优先级为4（高于任务A）    xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 4, NULL, 1);&#125;\n\n\n\n互斥锁![[Pasted image 20250518105647.png]]优先级：A&gt;B&gt;C，任务C与任务A优先级翻转，先C后B\n实例代码#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;freertos/semphr.h&quot;#include &quot;esp_log.h&quot;#include &quot;driver/gpio.h&quot;#include &quot;dht11.h&quot;  // DHT11 传感器头文件，需自行实现或引用// 定义一个互斥信号量句柄SemaphoreHandle_t dht11_mutex;// 任务A，读取温湿度并打印void taskA(void* param) &#123;    int temp, humidity;    while (1) &#123;        // 请求互斥信号量，独占访问DHT11        xSemaphoreTake(dht11_mutex, portMAX_DELAY);        // 延时500ms，确保DHT11准备好        vTaskDelay(pdMS_TO_TICKS(500));        // 如果成功读取DHT11数据        if (DHT11_StartGet(&amp;temp, &amp;humidity)) &#123;            // 打印温度和湿度（温度以整数形式除以10）            ESP_LOGI(&quot;dht11&quot;, &quot;taskA--&gt;temp:%d, humidity:%d%%&quot;, temp / 10, humidity);        &#125;        // 释放互斥信号量        xSemaphoreGive(dht11_mutex);        // 任务延时1000ms        vTaskDelay(pdMS_TO_TICKS(1000));    &#125;&#125;// 任务B，功能与任务A相同void taskB(void *param) &#123;    int temp, humidity;    while (1) &#123;        xSemaphoreTake(dht11_mutex, portMAX_DELAY);        vTaskDelay(pdMS_TO_TICKS(500));        if (DHT11_StartGet(&amp;temp, &amp;humidity)) &#123;            ESP_LOGI(&quot;dht11&quot;, &quot;taskB--&gt;temp:%d, humidity:%d%%&quot;, temp / 10, humidity);        &#125;        xSemaphoreGive(dht11_mutex);        vTaskDelay(pdMS_TO_TICKS(1000));    &#125;&#125;// 主函数void app_main(void) &#123;    // 创建一个二值信号量（用于互斥访问）    dht11_mutex = xSemaphoreCreateBinary();    // 注意：创建二值信号量后需要先释放一次，否则不能使用    xSemaphoreGive(dht11_mutex);    // 创建任务A，绑定到核心1，优先级为3，堆栈大小为2048字节    xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 3, NULL, 1);    // 创建任务B，绑定到核心1，优先级为3，堆栈大小为2048字节    xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 3, NULL, 1);&#125;\n\n\n\n\n\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","FreeRTOS"]},{"title":"1.创建任务","url":"/2025/05/20/esp-freertos/1.%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A11/","content":"任务可以存在于以下状态：运行：当任务实际执行时，它被称为处于运行状态。任务当前正在使用处理机。如果运行RTOS的处理器只有一个内核，那么在任何给定时间内都只能有一个任务处于运行状态。\n准备就绪：准备就绪任务指那些能够执行（它们不处于阻塞或挂起状态），但目前没有执行的任务，因为同等或更高优先级的不同任务已经处于运行状态。\n阻塞：如果任务当前正在等待时间或外部时间，则该任务被认为处于阻塞状态。例如，如果一个任务调用vTaskDelay()，它将被阻塞（被置于阻塞状态），直到延迟结束一个时间事件。任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量事件。处于阻塞状态的任务通常有一个“超时”期，超时后任务被超时，并被解除阻塞，即使该任务所等待的事件没有发生。\n“阻塞”状态下的任务不使用任何处理时间，不能 被选择进入运行状态。\n挂起：与“阻塞”状态下的任务一样，“挂起”状态下的任务不能 被选择进入运行状态，但处于挂起状态的任务 没有超时。相反，任务只有在分别通过vTaskSuspend() 和 xTaskResume() API调用明确命令时才会进入或退出挂起状态。\n任务创建![[Pasted image 20250515092426.png]]\nBase Type_t xTaskCreatePinnedToCore(\tTaskFunction pvTaskCode,//任务函数指针，原型是void fun(void *param)\tconst char * constpcName,//任务的名称，打印调试可能会有用\tconst uint32_t usStackDepth,//指定的任务堆栈空间大小（字节）\tvoid * constpvParameters,//任务参数\tUBaseType_t uxPriority,//优先级，数字越大，优先级越大，0到（configMAX_PRIORITIES-1）\tTaskHandle_t * constpvCreatedTask,//传回来的任务句柄\tconst BaseType_t xCoreID//分配在哪个内核运行)\n关于栈区大小任务在运行的时候,每个任务是来回切换运行的,操作系统在切换别的任务运行的时候,会把当前任务运行的寄存器,变量的值存储到内存(ram)里面.\n 当再次回到这个任务运行的时候,从内存把寄存器,变量的值读取出来,这样子的话就可以接着上次运行了.\n阻塞![[Pasted image 20250515094654.png]]\n//延时xTicksToDelay个周期void vTaskDelay(const TickType_t xTicksToDelay)//用于表示精确的解除阻塞时间void vTaskDelayUntil(TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement);//参数1：保存了上一次任务解除阻塞的时间，//参数2:1+2后结束阻塞cnt = xTaskGetTickCount();//获取当前系统节拍数while(1)&#123;\tvTaskDelayUntil(&amp;cnt, 100);\t···&#125;\n\n\n\n实例代码#include &lt;stdio.h&gt;#include &quot;esp_log.h&quot;#include &quot;freertos\\FreeRTOS.h&quot;#include &quot;freertos\\task.h&quot;QueueHandle_t queue_handle = NULL;typedef struct&#123;    int value;&#125;queue_data_t;void taskA(void * param)&#123;    while (1)    &#123;        ESP_LOGI(&quot;main&quot;,&quot;Hello world!&quot;);        vTaskDelay(pdMS_TO_TICKS(500));        //vTaskDelay(500/portTICK_PERIOD_MS);    &#125;&#125;void app_main(void)&#123;    xTaskCreatePinnedToCore(taskA, &quot;helloworld&quot;, 2048, NULL, 3, NULL, 1);&#125;\n\n\n难道使用了 2048-568 &#x3D; 1480 ????\n 一个啥也没有的任务不可能使用这么多的,其实返回的是这个任务运行的时候使用的最大空间.\n 但是网络是都是说这个函数是剩下的栈空间呢? 如何解释?\n其实是栈的生长方向的问题!\n首先呢保存数据就是使用的数组保存的,数组有首地址和尾地址.\n假设存储数据的时候是从首地址开始存储的,假设存储了568个数据,那么数据最大存储在568这个地址\n那么就剩余1480个空间没有使用.那么返回的时候返回剩下的就是1480;\n如果存储数据的时候是从数组的尾地址开始存储的,假设存储568个数据,其实数据是存储到 2047,2046,…,1479,1480 这些地址上\n最终存储的地址是1480,但是呢从数组的首地址开始计算的话就会认为存储了1480个数据\n那么便会计算出剩余568,正好和上面的相反.所以才返回568.\n一般呢把空间设置为实际使用空间的1.5倍或者2倍就可以 568****2&#x3D;1136\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","FreeRTOS"]},{"title":"5.对比","url":"/2025/05/21/esp-freertos/5%E3%80%81%E5%AF%B9%E6%AF%945/","content":"\n\n\n机制\n用途\n特点\n适用场景\n\n\n\n队列（Queue）\n传递数据\n支持多个数据项排队\n任务间传递结构体&#x2F;数值等数据\n\n\n信号量（Semaphore）\n同步 &#x2F; 互斥\n不传递数据，只传“信号”\n同步事件、任务间或中断间的配合\n\n\n互斥锁（Mutex）\n资源互斥保护\n特殊的二值信号量 + 优先级继承\n多任务访问共享资源（如 I²C、串口）\n\n\n事件组（Event Group）\n多位同步控制\n可同时表示多个状态位\n控制多个条件满足才执行，如联网、就绪等\n\n\n任务通知（Task Notification）\n点对点通知 + 可传值\n轻量，效率高，限单任务\n一对一传递信号或数据\n\n\n🧩 各模块详细对比1. ✅ 队列（Queue）\n可以传递数据（整数、结构体等）\n\n先进先出（FIFO）机制\n\n可以阻塞等待队列满或空\n\n支持任务与任务 &#x2F; 中断与任务之间通信\n\n\n🔧 示例用途：\nxQueueSend(queue, &amp;data, portMAX_DELAY);     // 发送数据 xQueueReceive(queue, &amp;data, portMAX_DELAY);  // 接收数据\n\n2. ✅ 信号量（Semaphore）2.1 二值信号量（Binary Semaphore）\n只表示 “有&#x2F;无” 两种状态，不传值\n\n用于同步（如：等待中断、事件触发）\n\n\n2.2 计数信号量（Counting Semaphore）\n可以累加的“计数器”\n\n适用于某种资源有多个实例\n\n\n🔧 示例用途：\nxSemaphoreGive(binary_sema);         // 发送信号（如 ISR 中） xSemaphoreTake(binary_sema, portMAX_DELAY);  // 等待信号\n\n3. ✅ 互斥锁（Mutex）\n本质是 带优先级继承的二值信号量\n\n专门用于多个任务之间 保护共享资源\n\n只允许一个任务持有，其他任务会阻塞等待\n\n任务释放后会恢复优先级，避免“优先级反转”问题\n\n\n🔧 示例用途：\nxSemaphoreTake(mutex, portMAX_DELAY);  // 上锁 // 访问共享资源... xSemaphoreGive(mutex);                 // 解锁\n\n4. ✅ 事件组（Event Group）\n用 位(bit) 表示多个事件状态（最多 24 个位）\n\n支持按位等待“任一位”或“所有位”\n\n适合多个状态控制组合，如：\n\nBIT0 表示联网成功\n\nBIT1 表示传感器初始化完成\n\nBIT2 表示时间同步完成\n\n\n\n\n🔧 示例用途：\nxEventGroupSetBits(event_group, BIT0 | BIT2); // 设置位 xEventGroupWaitBits(event_group, BIT0 | BIT2, pdTRUE, pdTRUE, portMAX_DELAY); // 等待两个事件位\n\n5. ✅ 任务通知（Task Notification）\n每个任务自带一个“私有”通知通道\n\n可传一个 uint32_t 值\n\n效率最高，占用最少\n\n适合一对一通知，不能一对多\n\n\n🔧 示例用途：\nxTaskNotify(task_handle, 1234, eSetValueWithOverwrite); // 发送通知值 xTaskNotifyWait(0, 0, &amp;value, portMAX_DELAY);            // 等待并接收通知值\n\n🧪 使用建议总结\n\n\n如果你要…\n用这个机制\n\n\n\n任务&#x2F;中断传输数据结构\n✅ 队列 Queue\n\n\n仅通知某事件发生\n✅ 二值信号量\n\n\n控制资源（如 I2C）访问顺序\n✅ 互斥锁 Mutex\n\n\n等待多个条件状态完成\n✅ 事件组 Event Group\n\n\n轻量、一对一传信号&#x2F;值\n✅ 任务通知 Task Notification\n\n\n\n📌 提示\n\n\n注意点\n说明\n\n\n\n队列最耗资源\n占用内存（需内部数组存放数据）\n\n\n任务通知最快\n每个任务只能有一个通知通道，适合一对一\n\n\n事件组不能传值\n只能用位来表示事件状态\n\n\n信号量没有值\n不能附带数据，只是“信号”\n\n\n互斥锁专用于资源保护\n不建议用作通用同步机制\n\n\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","FreeRTOS"]},{"title":"4.事件组和直达任务通知","url":"/2025/05/20/esp-freertos/4%E3%80%81%E4%BA%8B%E4%BB%B6%E7%BB%84%E5%92%8C%E7%9B%B4%E8%BE%BE%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A54/","content":"事件组事件位：用于指示事件是否发生，事件位通常称为事件标志；事件组：就是一组事件位。事件组中的事件位通过位编号来引用；\n![[Pasted image 20250518153023.png]]\n//创建一个事件组，返回事件组句柄，失败返回NULLEventGroupHandle_t xEventGroupCreate(void);//等待事件组中某个标志位，用返回值以确定哪些位已完成设置EventBits_t xEventGroupWaitBits(\tconst EventGroupHandle_t xEventGroup,//事件组句柄\tconst EventBits_t uxBitsToWaitFor,//哪些位需要等待\tconst BaseType_t xClearOnExit,//是否自动清除标志位\tconst BaseType_t xWaitForAllBits,//是否等待的标志位都成功了才返回\tTickType_t xTicksToWait//最大阻塞时间);//设置标志位EventBits xEventGroupSetBits(\tEventGroupHandle_t xEventGroup,//事件组句柄\tconst EventBits_t uxBitsToSet//设置哪个位)//清除标志位EventBits xEventGroupClearBits(\tEventGroupHandle_t xEventGroup,//事件组句柄\tconst EventBits_t uxBitsToClear//清除的标志位)\n\n实例代码#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/event_groups.h&quot;#include &quot;freertos/task.h&quot;#include &quot;esp_log.h&quot;// 定义事件位（位掩码）#define NUM0_BIT BIT0  // 即 0x01，事件位0#define NUM1_BIT BIT1  // 即 0x02，事件位1// 定义一个事件组句柄static EventGroupHandle_t test_event;// 任务A：每隔1秒设置一次事件位void taskA(void *param)&#123;    while (1)    &#123;        // 设置事件位 BIT0        xEventGroupSetBits(test_event, NUM0_BIT);        vTaskDelay(pdMS_TO_TICKS(1000));  // 延时1秒        // 设置事件位 BIT1        xEventGroupSetBits(test_event, NUM1_BIT);        vTaskDelay(pdMS_TO_TICKS(1000));  // 延时1秒    &#125;&#125;// 任务B：等待事件位的触发void taskB(void *param)&#123;    EventBits_t ev;    while (1)    &#123;        // 等待事件位 BIT0 或 BIT1 被设置，超时为5000毫秒        // pdTRUE 表示接收到事件后清除这些位        // pdFALSE 表示“或”逻辑，只要任意一位被置位就满足条件        ev = xEventGroupWaitBits(test_event, NUM0_BIT | NUM1_BIT, pdTRUE, pdFALSE, pdMS_TO_TICKS(5000));        // 检查是哪一个事件位被设置了        if (ev &amp; NUM0_BIT)        &#123;            ESP_LOGI(&quot;ev&quot;, &quot;get BIT0 event&quot;);        &#125;        if (ev &amp; NUM1_BIT)        &#123;            ESP_LOGI(&quot;ev&quot;, &quot;get BIT1 event&quot;);        &#125;    &#125;&#125;// 主函数void app_main(void)&#123;    // 创建事件组    test_event = xEventGroupCreate();    // 创建任务A：设置事件位    xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 3, NULL, 1);    // 创建任务B：等待事件位    xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 3, NULL, 1);&#125;\n\n\n\n\n内容\n解释\n\n\n\nEventGroupHandle_t\n事件组类型，用于管理多个事件位\n\n\nxEventGroupSetBits()\n设置一个或多个事件位\n\n\nxEventGroupWaitBits()\n等待某些事件位被置位\n\n\npdTRUE（清除标志）\n指定等待完成后是否自动清除这些事件位\n\n\npdFALSE（等待所有位）\n指定是否等待“所有位”置位（pdTRUE）或“任意一位”置位（pdFALSE）\n\n\n![[Pasted image 20250518155912.png]]\n\n\n\n\n直达任务通知每个RTOS任务都有一个任务通知组。每条任务通知 都有“挂起”或“非挂起”的通知状态，以及一个32位通知值。直达任务通知是直接发送至任务的事件，而不是通过中间对象（如队列、事件组或信号量）间接发送至任务的事件。向任务发送“直达任务通知”会将目标任务通知设为“挂起”状态（此挂起不是挂起任务）。\n用直达任务通知的时候，无需再初始化或新建其他对象句柄，直接使用任务句柄来操作通知的发送。说白了就是两个任务间可以直接通信，而不是像队列一样通过变量间接完成。\n![[Pasted image 20250518154256.png]]\n//用于将通知直接诶发送到RTOS任务并可能取消该任务的阻塞状态BaseType_t xTaskNotify(\tTaskHandle_t xTaskToNotify,//要通知的任务句柄\tuint32_t ulValue,//携带的通知值\teNotifyAction eAction,//执行的操作);//等待接收任务通知BaseType_t xTaskNotifyWait(\tuint32_t ulBitsToClearOnEntry,//进入函数清除的通知值位\tuint32_t ulBitsToClearOnExit,//退出函数清除的通知值位\tuint32_t * pulNotificationValue,//通知值\tTickType_t xTicksToWait//等待时长);\n\n\n实例代码#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/event_groups.h&quot;  // 此处未使用 event_groups，可省略#include &quot;freertos/task.h&quot;#include &quot;esp_log.h&quot;// 声明两个任务句柄static TaskHandle_t taskA_handle;static TaskHandle_t taskB_handle;// 任务A：定时向任务B发送任务通知void taskA(void *param)&#123;    uint32_t value = 0;  // 通知的值    vTaskDelay(pdMS_TO_TICKS(200));  // 启动延时 200ms，确保任务B已经创建    while (1)    &#123;        // 向任务B发送通知，附带 value 值        // 使用 eSetValueWithoutOverwrite 模式：如果任务B未接收上次通知，则不覆盖        xTaskNotify(taskB_handle, value, eSetValueWithoutOverwrite);        vTaskDelay(pdMS_TO_TICKS(1000));  // 每秒发送一次通知        value++;  // 通知值递增    &#125;&#125;// 任务B：等待并接收任务通知值，打印日志void taskB(void *param)&#123;    uint32_t value;  // 接收到的通知值    while (1)    &#123;        // 等待任务通知，阻塞时间为 portMAX_DELAY（即永久阻塞直到收到通知）        // 第一个参数：不清除任何已有的通知位        // 第二个参数：清除所有通知位        // 第三个参数：接收通知值        xTaskNotifyWait(0x00, ULONG_MAX, &amp;value, portMAX_DELAY);        // 打印接收到的通知值        ESP_LOGI(&quot;ev&quot;, &quot;notify wait value:%lu&quot;, value);    &#125;&#125;// 主函数void app_main(void)&#123;    // 创建任务A，并将任务句柄赋值给 taskA_handle    xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 3, &amp;taskA_handle, 1);    // 创建任务B，并将任务句柄赋值给 taskB_handle（必须，任务A要用到）    xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 3, &amp;taskB_handle, 1);&#125;\n\n\n\n![[Pasted image 20250518163208.png]]\n","categories":["ESP32-IDF开发笔记"],"tags":["ESP32","FreeRTOS"]}]